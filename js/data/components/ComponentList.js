/*
 * @Author: Code4GL
 * @Date: 2018-12-17 16:11:47
 * @Last Modified by: Code4GL
 * @Last Modified time: 2018-12-23 23:30:52
 */

'use strict';

/**
 * 组件列表单元构造方法
 * @param {String} key 序号
 * @param {String} name 组件名称
 * @param {String} description 英文描述
 * @param {String} descriptionCN 中文描述
 * @param {String} route 详情路由
 * @param {String} platform 支持平台:all，ios，android
 */
function ListCell (key, name, description, descriptionCN, note, noteCN, route, platform) {
  return ({
    key,
    name,
    description,
    descriptionCN,
    note,
    noteCN,
    route,
    platform
  });
}

const ComponentList = [
  ListCell('01', 'ActivityIndicator', 'Displays a circular loading indicator.', '显示循环加载指示器。', '', '', 'ActivityIndicator', 'all'),
  ListCell('02', 'Button', 'A basic button component that should render nicely on any platform. Supports a minimal level of customization.', '一个基本的按钮组件，可以在任何平台上很好地呈现。 支持最低级别的自定义。', '', '', 'Button', 'all'),
  ListCell('03', 'DatePickerIOS', "Use DatePickerIOS to render a date/time picker (selector) on iOS. This is a controlled component, so you must hook in to the onDateChange callback and update the date prop in order for the component to update, otherwise the user's change will be reverted immediately to reflect props.date as the source of truth.", '使用DatePickerIOS在iOS上呈现日期/时间选择器（选择器）。 这是一个受控组件，因此您必须挂钩onDateChange回调并更新日期道具以便组件更新，否则将立即恢复用户的更改以反映props.date作为事实的来源。', '', '', 'DatePickerIOS', 'ios'),
  ListCell('04', 'DrawerLayoutAndroid', 'React component that wraps the platform DrawerLayout (Android only). The Drawer (typically used for navigation) is rendered with renderNavigationView and direct children are the main view (where your content goes). The navigation view is initially not visible on the screen, but can be pulled in from the side of the window specified by the drawerPosition prop and its width can be set by the drawerWidth prop.', '包含平台DrawerLayout的React组件（仅限Android）。 抽屉（通常用于导航）使用renderNavigationView渲染，直接子视图是主视图（内容所在的位置）。 导航视图最初在屏幕上不可见，但可以从drawerPosition prop指定的窗口侧拉入，其宽度可以由drawerWidth prop设置。', '', '', 'DrawerLayoutAndroid', 'android'),
  ListCell('05', 'FlatList', 'A performant interface for rendering simple, flat lists, supporting the most handy features:Fully cross-platform.Optional horizontal mode.Configurable viewability callbacks.Header support.Footer support.Separator support.Pull to Refresh.Scroll loading.ScrollToIndex support.If you need section support, use <SectionList>.', '一个高性能的界面，用于渲染简单，扁平的列表，支持最方便的功能：完全跨平台，可选水平模式，可配置的可见度回调，标题支持，页脚支持，分隔支持，拉到刷新，滚动加载，ScrollToIndex支持。如果需要节支持，请使用<SectionList>。', '', '', 'FlatList', 'all'),
  ListCell('06', 'Image', "A React component for displaying different types of images, including network images, static resources, temporary local images, and images from local disk, such as the camera roll.This example shows fetching and displaying an image from local storage as well as one from network and even from data provided in the 'data:' uri scheme.", 'React组件，用于显示不同类型的图像，包括网络图像，静态资源，临时本地图像和本地磁盘中的图像，例如相机胶卷。此示例显示从本地存储中获取和显示图像，以及从网络中获取图像，甚至从“data：”uri方案中提供的数据。', 'Note that for network and data images, you will need to manually specify the dimensions of your image!', '请注意，对于网络和数据图像，您需要手动指定图像的尺寸！', 'Image', 'all'),
  ListCell('07', 'ImageBackground', "A common feature request from developers familiar with the web is background-image. To handle this use case, you can use the <ImageBackground> component, which has the same props as <Image>, and add whatever children to it you would like to layer on top of it.You might not want to use <ImageBackground> in some cases, since the implementation is very simple. Refer to <ImageBackground>'s source code for more insight, and create your own custom component when needed.", '熟悉Web的开发人员的常见功能请求是背景图像。 要处理此用例，您可以使用<ImageBackground>组件，该组件与<Image>具有相同的道具，并添加要在其上层叠的子项。在某些情况下，您可能不想使用<ImageBackground>，因为实现非常简单。 有关更多信息，请参阅<ImageBackground>的源代码，并在需要时创建自己的自定义组件。', 'Note that you must specify some width and height style attributes.', '请注意，您必须指定一些宽度和高度样式属性。', 'ImageBackground', 'all'),
  ListCell('08', 'InputAccessoryView', 'A component which enables customization of the keyboard input accessory view on iOS. The input accessory view is displayed above the keyboard whenever a TextInput has focus. This component can be used to create custom toolbars.To use this component wrap your custom toolbar with the InputAccessoryView component, and set a nativeID. Then, pass that nativeID as the inputAccessoryViewID of whatever TextInput you desire. ', '一个组件，可以在iOS上自定义键盘输入附件视图。 只要TextInput具有焦点，输入附件视图就会显示在键盘上方。 此组件可用于创建自定义工具栏。要使用此组件，请使用InputAccessoryView组件包装自定义工具栏，并设置nativeID。 然后，将该nativeID作为所需TextInput的inputAccessoryViewID传递。', '<InputAccessoryView> is not supported on Android yet.', 'Android尚不支持<InputAccessoryView>。', 'InputAccessoryView', 'ios'),
  ListCell('09', 'KeyboardAvoidingView', 'It is a component to solve the common problem of views that need to move out of the way of the virtual keyboard. It can automatically adjust either its position or bottom padding based on the position of the keyboard.', '它是解决需要移开虚拟键盘的视图的常见问题的组件。 它可以根据键盘的位置自动调整其位置或底部填充。', '', '', 'KeyboardAvoidingView', 'all'),
  ListCell('10', 'ListView', 'DEPRECATED - use one of the new list components, such as FlatList or SectionList for bounded memory use, fewer bugs, better performance, an easier to use API, and more features. Check out this blog post for more details.ListView - A core component designed for efficient display of vertically scrolling lists of changing data. The minimal API is to create a ListView.DataSource, populate it with a simple array of data blobs, and instantiate a ListView component with that data source and a renderRow callback which takes a blob from the data array and returns a renderable component.', 'DEPRECATED - 使用其中一个新的列表组件，例如FlatList或SectionList，用于有限内存使用，更少的错误，更好的性能，更易于使用的API以及更多功能。 查看此博客文章了解更多详情。ListView  - 一个核心组件，旨在高效显示垂直滚动的更改数据列表。 最小的API是创建ListView.DataSource，使用简单的数据blob数组填充它，并使用该数据源和renderRow回调实例化ListView组件，该回调从数据数组中获取blob并返回可渲染组件。', 'ListView is deprecated and will be removed in a future release. See https://fb.me/nolistview for more information', 'ListView已弃用，将在以后的版本中删除。 有关更多信息，请参阅https://fb.me/nolistview', 'ListView', 'all'),
  ListCell('11', 'MaskedViewIOS', 'Renders the child view with a mask specified in the maskElement prop.', '使用maskElement prop中指定的掩码呈现子视图。', '', '', 'MaskedViewIOS', 'ios'),
  ListCell('12', 'Modal', 'The Modal component is a simple way to present content above an enclosing view.', 'Modal组件是一种在封闭视图上方显示内容的简单方法。', 'Note: If you need more control over how to present modals over the rest of your app, then consider using a top-level Navigator.', '注意：如果您需要更多地控制如何在应用程序的其余部分上显示模态，请考虑使用顶级导航器。', 'Modal', 'all'),
  ListCell('13', 'NavigatorIOS', 'NavigatorIOS is a wrapper around UINavigationController, enabling you to implement a navigation stack. It works exactly the same as it would on a native app using UINavigationController, providing the same animations and behavior from UIKit.As the name implies, it is only available on iOS. Take a look at React Navigation for a cross-platform solution in JavaScript, or check out either of these components for native solutions: native-navigation, react-native-navigation.To set up the navigator, provide the initialRoute prop with a route object. A route object is used to describe each scene that your app navigates to. initialRoute represents the first route in your navigator.', 'NavigatorIOS是UINavigationController的包装器，使您能够实现导航堆栈。 它与使用UINavigationController的本机应用程序完全相同，从UIKit提供相同的动画和行为。顾名思义，它仅适用于iOS。 查看React Navigation以获取JavaScript中的跨平台解决方案，或者查看这些组件中的任何一个以获取本机解决方案：本机导航，react-native-navigation。要设置导航器，请为initialRoute prop提供路径对象。 路径对象用于描述您的应用导航到的每个场景。 initialRoute表示导航器中的第一条路线。', '', '', 'NavigatorIOS', 'ios'),
  ListCell('14', 'Picker', 'Renders the native picker component on iOS and Android.', '在iOS和Android上呈现本机选取器组件。', '', '', 'Picker', 'all'),
  ListCell('15', 'PickerIOS', 'No Description.', '没有描述。', '', '', 'PickerIOS', 'ios'),
  ListCell('16', 'ProgressBarAndroid', 'Android-only React component used to indicate that the app is loading or there is some activity in the app.', '仅限Android的React组件，用于指示应用程序正在加载或应用程序中存在某些活动。', '', '', 'ProgressBarAndroid', 'android'),
  ListCell('17', 'ProgressViewIOS', 'Use ProgressViewIOS to render a UIProgressView on iOS.', '使用ProgressViewIOS在iOS上呈现UIProgressView。', '', '', 'ProgressViewIOS', 'ios'),
  ListCell('18', 'RefreshControl', 'This component is used inside a ScrollView or ListView to add pull to refresh functionality. When the ScrollView is at scrollY: 0, swiping down triggers an onRefresh event.', '此组件在ScrollView或ListView中使用，以添加pull to refresh功能。 当ScrollView处于scrollY：0时，向下滑动会触发onRefresh事件。', '', '', 'RefreshControl', 'all'),
  ListCell('19', 'SafeAreaView', "The purpose of SafeAreaView is to render content within the safe area boundaries of a device. It is currently only applicable to iOS devices with iOS version 11 or later.SafeAreaView renders nested content and automatically applies paddings to reflect the portion of the view that is not covered by navigation bars, tab bars, toolbars, and other ancestor views. Moreover, and most importantly, Safe Area's paddings reflect the physical limitation of the screen, such as rounded corners or camera notches (i.e. the sensor housing area on iPhone X).", 'SafeAreaView的目的是在设备的安全区域边界内呈现内容。 目前仅适用于iOS 11或更高版本的iOS设备。SafeAreaView呈现嵌套内容并自动应用填充以反映导航栏，标签栏，工具栏和其他祖先视图未覆盖的视图部分。 此外，最重要的是，Safe Area的填充反映了屏幕的物理限制，例如圆角或相机凹口（即iPhone X上的传感器外壳区域）。', '', '', 'SafeAreaView', 'all'),
  ListCell('20', 'ScrollView', "Component that wraps platform ScrollView while providing integration with touch locking 'responder' system.Keep in mind that ScrollViews must have a bounded height in order to work, since they contain unbounded-height children into a bounded container (via a scroll interaction). In order to bound the height of a ScrollView, either set the height of the view directly (discouraged) or make sure all parent views have bounded height. Forgetting to transfer {flex: 1} down the view stack can lead to errors here, which the element inspector makes easy to debug.Doesn't yet support other contained responders from blocking this scroll view from becoming the responder.<ScrollView> vs <FlatList> - which one to use?ScrollView simply renders all its react child components at once. That makes it very easy to understand and use.On the other hand, this has a performance downside. Imagine you have a very long list of items you want to display, maybe several screens worth of content. Creating JS components and native views for everything all at once, much of which may not even be shown, will contribute to slow rendering and increased memory usage.This is where FlatList comes into play. FlatList renders items lazily, just when they are about to appear, and removes items that scroll way off screen to save memory and processing time.FlatList is also handy if you want to render separators between your items, multiple columns, infinite scroll loading, or any number of other features it supports out of the box.", '包含平台ScrollView的组件，同时提供与触摸锁定“响应器”系统的集成。请记住，ScrollViews必须具有有限的高度才能工作，因为它们将无界高度的子项包含在有界容器中（通过滚动交互）。为了限制ScrollView的高度，可以直接设置视图的高度（不鼓励），也可以确保所有父视图都具有有界高度。忘记在视图堆栈中向下传送{flex：1}可能会导致错误，元素检查器可以轻松调试。尚未支持其他包含的响应者阻止此滚动视图成为响应者。<ScrollView> vs <FlatList>  - 使用哪一个？ScrollView只是立即呈现其所有反应子组件。这使得它易于理解和使用。另一方面，这有性能下降。想象一下，你有一个很长的项目列表要显示，可能有几个屏幕的内容。同时为所有内容创建JS组件和本机视图（其中大部分甚至可能无法显示）将导致渲染速度降低和内存使用量增加。这就是FlatList发挥作用的地方。 FlatList会在项目即将出现时懒惰地呈现项目，并删除在屏幕外滚动的项目以节省内存和处理时间。如果要在项目，多列，无限滚动加载或其支持的任何其他功能之间渲染分隔符，FlatList也很方便。', '', '', 'ScrollView', 'all'),
  ListCell('21', 'SectionList', "A performant interface for rendering sectioned lists, supporting the most handy features:Fully cross-platform,Configurable viewability callbacks,List header support,List footer support,Item separator support,Section header support,Section separator support,Heterogeneous data and item rendering support,Pull to Refresh,Scroll loading.If you don't need section support and want a simpler interface, use <FlatList>.", '一个高性能的界面，用于呈现分段列表，支持最方便的功能：完全跨平台,可配置的可见度回调,列表标题支持,列表页脚支持,项目分隔符支持,节头支持,节分隔符支持,异构数据和项呈现支持,拉到刷新,滚动加载。如果您不需要节支持并希望使用更简单的界面，请使用<FlatList>。', '', '', 'SectionList', 'all'),
  ListCell('22', 'SegmentedControlIOS', 'Use SegmentedControlIOS to render a UISegmentedControl iOS.Programmatically changing selected index.The selected index can be changed on the fly by assigning the selectedIndex prop to a state variable, then changing that variable. Note that the state variable would need to be updated as the user selects a value and changes the index, as shown in the example below.', '使用SegmentedControlIOS渲染UISegmentedControl iOS。以编程方式更改所选索引通过将selectedIndex prop分配给状态变量，然后更改该变量，可以动态更改所选索引。 请注意，当用户选择一个值并更改索引时，需要更新状态变量，如下例所示。', '', '', 'SegmentedControlIOS', 'ios'),
  ListCell('23', 'Slider', 'A component used to select a single value from a range of values.', '用于从一系列值中选择单个值的组件。', '', '', 'Slider', 'all'),
  ListCell('24', 'SnapshotViewIOS', 'No Description.', '没有描述。', '', '', 'SnapshotViewIOS', 'ios'),
  ListCell('25', 'StatusBar', 'Component to control the app status bar.', '用于控制应用状态栏的组件。', '', '', 'StatusBar', 'all'),
  ListCell('26', 'Switch', 'Renders a boolean input.This is a controlled component that requires an onValueChange callback that updates the value prop in order for the component to reflect user actions. If the value prop is not updated, the component will continue to render the supplied value prop instead of the expected result of any user actions.', '呈现布尔输入。这是一个受控组件，需要onValueChange回调来更新值prop，以便组件反映用户操作。 如果未更新值prop，则组件将继续呈现提供的值prop而不是任何用户操作的预期结果。', '', '', 'Switch', 'all'),
  ListCell('27', 'TabBarIOS', 'No Description.', '没有描述。', '', '', 'TabBarIOS', 'ios'),
  ListCell('28', 'TabBarIOS.Item', 'No Description.', '没有描述。', '', '', 'TabBarIOS.Item', 'ios'),
  ListCell('29', 'Text', 'A React component for displaying text.Text supports nesting, styling, and touch handling.In the following example, the nested title and body text will inherit the fontFamily from styles.baseText, but the title provides its own additional styles. ', '用于显示text.Text的React组件支持嵌套，样式和触摸处理。在以下示例中，嵌套的标题和正文文本将从styles.baseText继承fontFamily，但标题提供了自己的其他样式。', '', '', 'Text', 'all'),
  ListCell('30', 'TextInput', 'A foundational component for inputting text into the app via a keyboard. Props provide configurability for several features, such as auto-correction, auto-capitalization, placeholder text, and different keyboard types, such as a numeric keypad.The simplest use case is to plop down a TextInput and subscribe to the onChangeText events to read the user input. There are also other events, such as onSubmitEditing and onFocus that can be subscribed to.', '用于通过键盘将文本输入应用程序的基础组件。 道具为几个功能提供了可配置性，例如自动更正，自动大写，占位符文本和不同的键盘类型，例如数字小键盘。最简单的用例是放下TextInput并订阅onChangeText事件来读取 用户输入。 还有其他事件，例如可以订阅的onSubmitEditing和onFocus。', '', '', 'TextInput', 'all'),
  ListCell('31', 'ToolbarAndroid', "React component that wraps the Android-only Toolbar widget. A Toolbar can display a logo, navigation icon (e.g. hamburger menu), a title & subtitle and a list of actions. The title and subtitle are expanded so the logo and navigation icons are displayed on the left, title and subtitle in the middle and the actions on the right.If the toolbar has an only child, it will be displayed between the title and actions.Although the Toolbar supports remote images for the logo, navigation and action icons, this should only be used in DEV mode where require('./some_icon.png') translates into a packager URL. In release mode you should always use a drawable resource for these icons. Using require('./some_icon.png') will do this automatically for you, so as long as you don't explicitly use e.g. {uri: 'http://...'}, you will be good.", "包含仅限Android的工具栏小部件的React组件。 工具栏可以显示徽标，导航图标（例如汉堡菜单），标题和副标题以及动作列表。 标题和副标题被扩展，因此徽标和导航图标显示在左侧，标题和副标题显示在中间，操作显示在右侧。如果工具栏中只有一个子项，它将显示在标题和操作之间。 工具栏支持徽标，导航和操作图标的远程图像，这只应在DEV模式下使用，其中require（'./ some_icon.png'）转换为打包器URL。 在发布模式下，您应始终为这些图标使用可绘制资源。 使用require（'。/ some_icon.png'）将自动为您执行此操作，因此只要您没有明确使用例如 {uri：'http：// ...'}，你会很好。", '', '', 'ToolbarAndroid', 'android'),
  ListCell('32', 'TouchableHighlight', "A wrapper for making views respond properly to touches. On press down, the opacity of the wrapped view is decreased, which allows the underlay color to show through, darkening or tinting the view.The underlay comes from wrapping the child in a new View, which can affect layout, and sometimes cause unwanted visual artifacts if not used correctly, for example if the backgroundColor of the wrapped view isn't explicitly set to an opaque color.TouchableHighlight must have one child (not zero or more than one). If you wish to have several child components, wrap them in a View.", '用于使视图正确响应触摸的包装器。 按下时，包装视图的不透明度降低，这允许底色显示透视，变暗或着色视图。底层来自于将孩子包裹在新视图中，这可能会影响布局，有时会导致不必要的视觉效果 如果未正确使用工件，例如，如果包装视图的backgroundColor未显式设置为不透明颜色.TouchableHighlight必须有一个子项（不是零或多于一个）。 如果您希望拥有多个子组件，请将它们包装在视图中。', '', '', 'TouchableHighlight', 'all'),
  ListCell('33', 'TouchableNativeFeedback', "A wrapper for making views respond properly to touches (Android only). On Android this component uses native state drawable to display touch feedback.At the moment it only supports having a single View instance as a child node, as it's implemented by replacing that View with another instance of RCTView node with some additional properties set.Background drawable of native feedback touchable can be customized with background property.", '用于使视图正确响应触摸的包装器（仅限Android）。 在Android上，此组件使用本机状态drawable来显示触摸反馈。目前它只支持将单个View实例作为子节点，因为它是通过用另一个RCTView节点实例替换该View并使用一些其他属性set实现的.Background drawable 可触摸的原生反馈可以使用background属性进行自定义。', '', '', 'TouchableNativeFeedback', 'all'),
  ListCell('34', 'TouchableOpacity', 'A wrapper for making views respond properly to touches. On press down, the opacity of the wrapped view is decreased, dimming it.Opacity is controlled by wrapping the children in an Animated.View, which is added to the view hierarchy. Be aware that this can affect layout.', '用于使视图正确响应触摸的包装器。 在按下时，包装视图的不透明度会降低，使其变暗。通过将子项包装在Animated.View中来控制容量，该Animated.View将添加到视图层次结构中。 请注意，这可能会影响布局。', '', '', 'TouchableOpacity', 'all'),
  ListCell('35', 'TouchableWithoutFeedback', 'Do not use unless you have a very good reason. All elements that respond to press should have a visual feedback when touched.TouchableWithoutFeedback supports only one child. If you wish to have several child components, wrap them in a View.', '除非你有充分的理由，否则不要使用。 所有响应按下的元素在触摸时都应该有视觉反馈.TouchableWithoutFeedback仅支持一个孩子。 如果您希望拥有多个子组件，请将它们包装在视图中。', '', '', 'TouchableWithoutFeedback', 'all'),
  ListCell('36', 'View', 'The most fundamental component for building a UI, View is a container that supports layout with flexbox, style, some touch handling, and accessibility controls. View maps directly to the native view equivalent on whatever platform React Native is running on, whether that is a UIView, <div>, android.view, etc.View is designed to be nested inside other views and can have 0 to many children of any type.', '构建UI的最基本组件是View，它是一个支持flexbox，样式，一些触摸处理和可访问性控件的布局的容器。 在任何运行React Native的平台上直接查看映射到本机视图，无论是UIView，<div>，android.view等.View被设计为嵌套在其他视图中，并且可以有0到多个子节点 随便哪种。', 'Views are designed to be used with StyleSheet for clarity and performance, although inline styles are also supported.', '虽然也支持内联样式，但视图旨在与StyleSheet一起使用以获得清晰度和性能。', 'View', 'all'),
  ListCell('37', 'ViewPagerAndroid', 'Container that allows to flip left and right between child views. Each child view of the ViewPagerAndroid will be treated as a separate page and will be stretched to fill the ViewPagerAndroid.It is important all children are <View>s and not composite components. You can set style properties like padding or backgroundColor for each child. It is also important that each child have a key prop.', '允许在子视图之间左右翻转的容器。 ViewPagerAndroid的每个子视图都将被视为一个单独的页面，并将被拉伸以填充ViewPagerAndroid。重要的是所有子视图都是<View>而不是复合组件。 您可以为每个子项设置样式属性，如填充或backgroundColor。 每个孩子都有一个关键的道具也很重要。', '', '', 'ViewPagerAndroid', 'android'),
  ListCell('38', 'VirtualizedList', 'Base implementation for the more convenient <FlatList> and <SectionList> components, which are also better documented. In general, this should only really be used if you need more flexibility than FlatList provides, e.g. for use with immutable data instead of plain arrays.Virtualization massively improves memory consumption and performance of large lists by maintaining a finite render window of active items and replacing all items outside of the render window with appropriately sized blank space. The window adapts to scrolling behavior, and items are rendered incrementally with low-pri (after any running interactions) if they are far from the visible area, or with hi-pri otherwise to minimize the potential of seeing blank space.', '更方便的<FlatList>和<SectionList>组件的基本实现，这些组件也有更好的文档记录。 通常，只有在需要比FlatList提供的更多灵活性时才应该使用它，例如， 用于不可变数据而不是普通数组。虚拟化通过维护活动项的有限渲染窗口并用适当大小的空格替换渲染窗口之外的所有项，大大提高了大型列表的内存消耗和性能。 窗口适应滚动行为，如果远离可见区域，则以低pri（在任何正在运行的交互之后）逐渐呈现项目，或者使用hi-pri以最小化看到空白空间的可能性。', '', '', 'VirtualizedList', 'all'),
  ListCell('39', 'WebView', 'No Description.', '没有描述。', 'Warning Please use the react-native-community/react-native-webview fork of this component instead. To reduce the surface area of React Native, <WebView/> is going to be removed from the React Native core. For more information, please read The Slimmening proposal.Security Warning: Currently, onMessage and postMessage do not allow specifying an origin. This can lead to cross-site scripting attacks if an unexpected document is loaded within a WebView instance. Please refer to the MDN documentation for Window.postMessage() for more details on the security implications of this.', '警告请使用此组件的react-native-community / react-native-webview fork。 为了减少React Native的表面积，将从React Native核心中删除<WebView />。 有关详细信息，请阅读Slimmening提案。安全警告：目前，onMessage和postMessage不允许指定原点。 如果在WebView实例中加载了意外文档，这可能会导致跨站点脚本攻击。 有关此安全问题的更多详细信息，请参阅Window.postMessage（）的MDN文档。', 'WebView', 'all')
];

export default ComponentList;
